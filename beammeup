#!/usr/bin/env bash
set -euo pipefail

DEFAULT_SSH_PORT=22
DEFAULT_SSH_USER="root"
DEFAULT_SOCKS_PORT=1080
DEFAULT_HTTP_PORT=18181
DEFAULT_BASE_URL="https://beammeup.pw"
DEFAULT_SHIPS_DIR="${HOME:-.}/.beammeup/ships"
BEAMMEUP_VERSION="1.4.0"
USE_TUI=0

info() {
  printf '[beammeup] %s\n' "$*"
}

die() {
  printf '[beammeup] ERROR: %s\n' "$*" >&2
  exit 1
}

phase() {
  local index="$1"
  local total="$2"
  local label="$3"
  printf '\n[%s/%s] %s\n\n' "$index" "$total" "$label"
}

box_line() {
  printf '| %-62s |\n' "$1"
}

require_tui() {
  command -v dialog >/dev/null 2>&1 || die "Interactive mode requires 'dialog'. Install it first (macOS: brew install dialog, Debian/Ubuntu: apt-get install dialog)."
}

tui_input() {
  local title="$1"
  local prompt="$2"
  local initial="${3:-}"
  local tmp
  tmp="$(mktemp -t beammeup-dialog.XXXXXX)"
  if dialog --clear \
    --backtitle "beammeup v${BEAMMEUP_VERSION}" \
    --title "$title" \
    --inputbox "$prompt" 12 80 "$initial" 2>"$tmp"; then
    cat "$tmp"
    rm -f "$tmp"
    return 0
  fi
  rm -f "$tmp"
  return 1
}

tui_password() {
  local title="$1"
  local prompt="$2"
  local tmp
  tmp="$(mktemp -t beammeup-dialog.XXXXXX)"
  if dialog --clear \
    --backtitle "beammeup v${BEAMMEUP_VERSION}" \
    --title "$title" \
    --insecure \
    --passwordbox "$prompt" 12 80 2>"$tmp"; then
    cat "$tmp"
    rm -f "$tmp"
    return 0
  fi
  rm -f "$tmp"
  return 1
}

tui_menu() {
  local title="$1"
  local prompt="$2"
  shift 2
  local tmp
  tmp="$(mktemp -t beammeup-dialog.XXXXXX)"
  if dialog --clear \
    --backtitle "beammeup v${BEAMMEUP_VERSION}" \
    --title "$title" \
    --menu "$prompt" 20 90 10 "$@" 2>"$tmp"; then
    cat "$tmp"
    rm -f "$tmp"
    return 0
  fi
  rm -f "$tmp"
  return 1
}

tui_yesno() {
  local title="$1"
  local prompt="$2"
  local default_answer="$3"
  local default_flag=()
  if [[ "$default_answer" =~ ^[Nn]$ ]]; then
    default_flag+=(--defaultno)
  fi
  dialog --clear \
    --backtitle "beammeup v${BEAMMEUP_VERSION}" \
    --title "$title" \
    "${default_flag[@]}" \
    --yesno "$prompt" 10 80
}

tui_msg() {
  local title="$1"
  local message="$2"
  dialog --clear \
    --backtitle "beammeup v${BEAMMEUP_VERSION}" \
    --title "$title" \
    --msgbox "$message" 12 80
}

print_help() {
  cat <<'HELP'
beammeup: manage HTTP/SOCKS5 proxy setups on a VPS via SSH.

Usage:
  beammeup [options]

Options:
  --host <ip-or-hostname>       VPS host or IP
  --ship <name>                 Use saved ship profile from ~/.beammeup/ships
  --list-ships                  List saved ship profiles and exit
  --ssh-port <port>             SSH port (default: 22)
  --ssh-user <username>         SSH user (default: root)
  --ssh-password <password>     SSH password (discouraged on shared shells)
  --protocol <http|socks5>      Target protocol for show/configure actions
  --proxy-port <port>           Proxy port for configure/preflight
  --action <show|configure|rotate|destroy>
                                show: display current setup
                                configure: install/update setup (keep creds)
                                rotate: install/update and rotate credentials
                                destroy: destroy hangar (remove beammeup server config)
  --show-inventory              List detected beammeup setups and exit
  --preflight-only              Run checks only, make no remote changes
  --no-firewall-change          Do not add firewall rules on the VPS
  --self-update                 Update local beammeup from the release URL and exit
  --auto-update                 Update local beammeup before running requested action
  --base-url <https-url>        Override release base URL (default: https://beammeup.pw)
  --version                     Print beammeup version and exit
  --yes                         Skip confirmation prompts
  -h, --help                    Show this help

Environment:
  BEAMMEUP_AUTO_UPDATE=1        Auto-run self-update on startup
  BEAMMEUP_SHIPS_DIR            Override ship profile directory
HELP
}

is_valid_port() {
  local port="$1"
  [[ "$port" =~ ^[0-9]+$ ]] || return 1
  (( port >= 1 && port <= 65535 ))
}

to_lower() {
  printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}

normalize_protocol() {
  local value
  value="$(to_lower "$1")"
  case "$value" in
    socks|socks5)
      printf 'socks5'
      ;;
    http)
      printf 'http'
      ;;
    *)
      return 1
      ;;
  esac
}

normalize_action() {
  local value
  value="$(to_lower "$1")"
  case "$value" in
    show|configure|rotate|destroy)
      printf '%s' "$value"
      ;;
    install)
      printf 'configure'
      ;;
    uninstall)
      printf 'destroy'
      ;;
    *)
      return 1
      ;;
  esac
}

prompt_required() {
  local label="$1"
  local input=""
  while [[ -z "$input" ]]; do
    if [[ "$USE_TUI" -eq 1 ]]; then
      require_tui
      input="$(tui_input "beammeup" "$label" "")" || die "Cancelled."
    else
      read -r -p "$label: " input
    fi
  done
  printf '%s' "$input"
}

prompt_with_default() {
  local label="$1"
  local default_value="$2"
  local input
  if [[ "$USE_TUI" -eq 1 ]]; then
    require_tui
    input="$(tui_input "beammeup" "$label" "$default_value")" || die "Cancelled."
  else
    if [[ -n "$default_value" ]]; then
      read -r -p "$label [$default_value]: " input
    else
      read -r -p "$label: " input
    fi
  fi
  if [[ -z "$input" ]]; then
    printf '%s' "$default_value"
  else
    printf '%s' "$input"
  fi
}

extract_value() {
  local key="$1"
  local raw="$2"
  local line
  line="$(printf '%s\n' "$raw" | grep -m1 "^${key}=" || true)"
  if [[ -z "$line" ]]; then
    return 1
  fi
  printf '%s' "${line#*=}"
}

ship_file_path() {
  local ship_name="$1"
  printf '%s/%s.ship' "$SHIPS_DIR" "$ship_name"
}

sanitize_ship_name() {
  local raw="$1"
  raw="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')"
  printf '%s' "$raw" | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//; s/-{2,}/-/g'
}

ensure_ships_dir() {
  mkdir -p "$SHIPS_DIR"
}

read_ship_value() {
  local file="$1"
  local key="$2"
  grep -m1 "^${key}=" "$file" | cut -d= -f2- || true
}

list_ship_names() {
  ensure_ships_dir
  local file
  for file in "$SHIPS_DIR"/*.ship; do
    [[ -e "$file" ]] || continue
    basename "$file" .ship
  done | sort
}

print_ship_list() {
  local ships
  ships="$(list_ship_names || true)"
  if [[ -z "$ships" ]]; then
    printf 'No ships saved yet in %s\n' "$SHIPS_DIR"
    return
  fi

  printf 'Saved ships (%s):\n' "$SHIPS_DIR"
  printf '%s\n' "$ships" | while IFS= read -r ship; do
    [[ -n "$ship" ]] || continue
    printf '  - %s\n' "$ship"
  done
}

apply_ship_profile() {
  local ship_name="$1"
  local ship_file
  local ship_host ship_ssh_port ship_ssh_user ship_protocol ship_proxy_port ship_no_firewall

  ship_file="$(ship_file_path "$ship_name")"
  [[ -f "$ship_file" ]] || die "Ship '$ship_name' not found in $SHIPS_DIR"

  ship_host="$(read_ship_value "$ship_file" HOST)"
  ship_ssh_port="$(read_ship_value "$ship_file" SSH_PORT)"
  ship_ssh_user="$(read_ship_value "$ship_file" SSH_USER)"
  ship_protocol="$(read_ship_value "$ship_file" PROTOCOL)"
  ship_proxy_port="$(read_ship_value "$ship_file" PROXY_PORT)"
  ship_no_firewall="$(read_ship_value "$ship_file" NO_FIREWALL_CHANGE)"

  if [[ "$ARG_HOST_SET" -eq 0 && -n "$ship_host" ]]; then
    HOST="$ship_host"
  fi
  if [[ "$ARG_SSH_PORT_SET" -eq 0 && -n "$ship_ssh_port" ]]; then
    SSH_PORT="$ship_ssh_port"
  fi
  if [[ "$ARG_SSH_USER_SET" -eq 0 && -n "$ship_ssh_user" ]]; then
    SSH_USER="$ship_ssh_user"
  fi
  if [[ "$ARG_PROTOCOL_SET" -eq 0 && -n "$ship_protocol" ]]; then
    PROTOCOL="$ship_protocol"
  fi
  if [[ "$ARG_PROXY_PORT_SET" -eq 0 && -n "$ship_proxy_port" ]]; then
    PROXY_PORT="$ship_proxy_port"
  fi
  if [[ "$ARG_NO_FIREWALL_SET" -eq 0 && -n "$ship_no_firewall" ]]; then
    NO_FIREWALL_CHANGE="$ship_no_firewall"
  fi
}

persist_ship_profile() {
  local ship_name="$1"
  local ship_file

  [[ -n "$ship_name" ]] || return 0
  ensure_ships_dir
  ship_file="$(ship_file_path "$ship_name")"

  cat >"$ship_file" <<EOF_SHIP
HOST=$HOST
SSH_PORT=$SSH_PORT
SSH_USER=$SSH_USER
PROTOCOL=$PROTOCOL
PROXY_PORT=$PROXY_PORT
NO_FIREWALL_CHANGE=$NO_FIREWALL_CHANGE
EOF_SHIP
  chmod 600 "$ship_file"
}

prompt_protocol_choice() {
  local default_protocol="${1:-http}"
  local prompt_default_label="1"
  local choice

  if [[ "$USE_TUI" -eq 1 ]]; then
    require_tui
    if [[ "$default_protocol" == "socks5" ]]; then
      choice="2"
    else
      choice="1"
    fi
    choice="$(
      tui_menu \
        "transport protocol" \
        "choose transport protocol:" \
        "1" "HTTP (recommended for Chrome extension auth)" \
        "2" "SOCKS5"
    )" || die "Cancelled."
    case "$choice" in
      1) printf 'http' ;;
      2) printf 'socks5' ;;
      *) die "Invalid protocol choice." ;;
    esac
    return
  fi

  if [[ "$default_protocol" == "socks5" ]]; then
    prompt_default_label="2"
  fi

  printf '\nChoose transport protocol:\n' >&2
  printf '  1) HTTP (recommended for Chrome extension auth)\n' >&2
  printf '  2) SOCKS5\n' >&2

  while true; do
    read -r -p "Selection [1-2] (default: ${prompt_default_label}): " choice
    case "${choice:-$prompt_default_label}" in
      1)
        printf 'http'
        return
        ;;
      2)
        printf 'socks5'
        return
        ;;
      *)
        printf 'Please choose 1 or 2.\n' >&2
        ;;
    esac
  done
}

prompt_yes_no_default() {
  local prompt="$1"
  local default_answer="$2"
  local answer

  if [[ "$USE_TUI" -eq 1 ]]; then
    require_tui
    if tui_yesno "confirmation" "$prompt" "$default_answer"; then
      return 0
    fi
    return 1
  fi

  read -r -p "$prompt [$default_answer]: " answer
  case "${answer:-$default_answer}" in
    Y|y|yes|YES)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

collect_ship_fields() {
  local default_protocol default_port firewall_default

  HOST="$(prompt_with_default "Target VPS host/IP" "${HOST:-}")"
  while [[ -z "$HOST" ]]; do
    HOST="$(prompt_required "Target VPS host/IP")"
  done

  SSH_PORT="$(prompt_with_default "SSH port" "${SSH_PORT:-$DEFAULT_SSH_PORT}")"
  while ! is_valid_port "$SSH_PORT"; do
    printf 'Invalid port.\n'
    SSH_PORT="$(prompt_with_default "SSH port" "$DEFAULT_SSH_PORT")"
  done

  SSH_USER="$(prompt_with_default "SSH user" "${SSH_USER:-$DEFAULT_SSH_USER}")"
  while [[ -z "$SSH_USER" ]]; do
    SSH_USER="$(prompt_required "SSH user")"
  done

  default_protocol="${PROTOCOL:-http}"
  PROTOCOL="$(prompt_protocol_choice "$default_protocol")"

  if [[ "$PROTOCOL" == "http" ]]; then
    default_port="${PROXY_PORT:-$DEFAULT_HTTP_PORT}"
  else
    default_port="${PROXY_PORT:-$DEFAULT_SOCKS_PORT}"
  fi
  PROXY_PORT="$(prompt_with_default "Proxy port" "$default_port")"
  while ! is_valid_port "$PROXY_PORT"; do
    printf 'Invalid port.\n'
    PROXY_PORT="$(prompt_with_default "Proxy port" "$default_port")"
  done

  firewall_default="Y"
  if [[ "$NO_FIREWALL_CHANGE" -eq 1 ]]; then
    firewall_default="n"
  fi
  if prompt_yes_no_default "Allow beammeup to open firewall if needed?" "$firewall_default"; then
    NO_FIREWALL_CHANGE=0
  else
    NO_FIREWALL_CHANGE=1
  fi
}

choose_existing_ship() {
  local ships=()
  local index choice max
  mapfile -t ships < <(list_ship_names)
  if [[ "${#ships[@]}" -eq 0 ]]; then
    return 1
  fi

  if [[ "$USE_TUI" -eq 1 ]]; then
    require_tui
    local options=()
    for index in "${!ships[@]}"; do
      options+=("${ships[$index]}" "saved ship profile")
    done
    options+=("new" "create a new ship")
    choice="$(tui_menu "ships" "select a ship to launch" "${options[@]}")" || die "Cancelled."
    if [[ "$choice" == "new" ]]; then
      return 1
    fi
    printf '%s' "$choice"
    return 0
  fi

  printf '\nSaved ships:\n' >&2
  for index in "${!ships[@]}"; do
    printf '  %d) %s\n' "$((index + 1))" "${ships[$index]}" >&2
  done
  printf '  n) create a new ship\n' >&2

  max="${#ships[@]}"
  while true; do
    read -r -p "Select ship [1-${max} or n]: " choice
    if [[ "${choice,,}" == "n" ]]; then
      return 1
    fi
    if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= max )); then
      printf '%s' "${ships[$((choice - 1))]}"
      return 0
    fi
    printf 'Please pick a valid ship.\n' >&2
  done
}

pick_ship_for_abandon() {
  local ships=()
  local index
  local options=()
  mapfile -t ships < <(list_ship_names)
  if [[ "${#ships[@]}" -eq 0 ]]; then
    return 1
  fi

  if [[ "$USE_TUI" -eq 1 ]]; then
    require_tui
    for index in "${!ships[@]}"; do
      options+=("${ships[$index]}" "delete local profile")
    done
    tui_menu "abandon ship" "select local ship profile to delete" "${options[@]}"
    return $?
  fi

  printf '\nSaved ships:\n' >&2
  for index in "${!ships[@]}"; do
    printf '  %d) %s\n' "$((index + 1))" "${ships[$index]}" >&2
  done
  printf '  n) cancel\n' >&2

  while true; do
    read -r -p "Select ship [1-${#ships[@]} or n]: " index
    if [[ "${index,,}" == "n" ]]; then
      return 1
    fi
    if [[ "$index" =~ ^[0-9]+$ ]] && (( index >= 1 && index <= ${#ships[@]} )); then
      printf '%s' "${ships[$((index - 1))]}"
      return 0
    fi
    printf 'Please pick a valid ship.\n' >&2
  done
}

abandon_ship_local() {
  local victim="$1"
  local ship_file
  ship_file="$(ship_file_path "$victim")"
  [[ -f "$ship_file" ]] || return 0
  rm -f "$ship_file"
}

interactive_ship_wizard() {
  local selected_ship=""
  local raw_ship_name=""
  local deck_action=""
  local victim_ship=""

  ensure_ships_dir
  require_tui
  tui_msg "welcome aboard" "beammeup v${BEAMMEUP_VERSION}\n\nships are saved in:\n${SHIPS_DIR}\n\nship files store host/protocol details, never ssh passwords."

  while true; do
    if [[ -n "$(list_ship_names || true)" ]]; then
      deck_action="$(
        tui_menu \
          "command deck" \
          "choose an action" \
          "launch" "launch using a saved ship" \
          "new" "create a new ship" \
          "abandon" "abandon ship (delete local .ship)" \
          "exit" "exit beammeup"
      )" || die "Cancelled."
    else
      deck_action="new"
    fi

    case "$deck_action" in
      launch)
        selected_ship="$(choose_existing_ship)" || continue
        SHIP_NAME="$selected_ship"
        apply_ship_profile "$SHIP_NAME"
        if prompt_yes_no_default "Edit this ship before launch?" "n"; then
          collect_ship_fields
          persist_ship_profile "$SHIP_NAME"
        fi
        return
        ;;
      new)
        while true; do
          raw_ship_name="$(prompt_required "Name your ship")"
          SHIP_NAME="$(sanitize_ship_name "$raw_ship_name")"
          if [[ -z "$SHIP_NAME" ]]; then
            tui_msg "invalid name" "Ship name must include letters or numbers."
            continue
          fi
          if [[ -f "$(ship_file_path "$SHIP_NAME")" ]]; then
            if prompt_yes_no_default "Ship '$SHIP_NAME' exists. Overwrite?" "n"; then
              break
            fi
            continue
          fi
          break
        done

        HOST=""
        SSH_PORT="$DEFAULT_SSH_PORT"
        SSH_USER="$DEFAULT_SSH_USER"
        PROTOCOL="http"
        PROXY_PORT="$DEFAULT_HTTP_PORT"
        NO_FIREWALL_CHANGE=0
        collect_ship_fields
        persist_ship_profile "$SHIP_NAME"
        return
        ;;
      abandon)
        victim_ship="$(pick_ship_for_abandon || true)"
        if [[ -z "$victim_ship" ]]; then
          tui_msg "abandon ship" "No ships available to abandon."
          continue
        fi
        if prompt_yes_no_default "Abandon ship '$victim_ship'? This deletes local profile only." "n"; then
          abandon_ship_local "$victim_ship"
          tui_msg "ship abandoned" "Local ship '$victim_ship' deleted."
        fi
        ;;
      exit)
        die "Cancelled."
        ;;
      *)
        die "Unknown wizard action: $deck_action"
        ;;
    esac
  done
}

prompt_action_choice() {
  local protocol="$1"
  local protocol_label
  local choice
  protocol_label="$( [[ "$protocol" == "http" ]] && echo "HTTP" || echo "SOCKS5" )"

  if [[ "$USE_TUI" -eq 1 ]]; then
    choice="$(
      tui_menu \
        "mission action (${protocol_label})" \
        "choose action for ${protocol_label}" \
        "show" "show current setup" \
        "configure" "configure/repair (keep credentials)" \
        "rotate" "rotate credentials and configure" \
        "destroy" "destroy hangar (remove server beammeup config)"
    )" || die "Cancelled."
    printf '%s' "$choice"
    return
  fi

  printf '\nCommand options for %s:\n' "$protocol_label"
  printf '  1) Show current setup\n'
  printf '  2) Configure/repair (keep credentials)\n'
  printf '  3) Rotate credentials and configure\n'
  printf '  4) Destroy hangar (remove server beammeup config)\n'
  while true; do
    read -r -p "Selection [1-4]: " choice
    case "$choice" in
      1) printf 'show'; return ;;
      2) printf 'configure'; return ;;
      3) printf 'rotate'; return ;;
      4) printf 'destroy'; return ;;
      *) printf 'Please choose 1, 2, 3, or 4.\n' ;;
    esac
  done
}

confirm_destroy_hangar() {
  local confirm_text=""
  if [[ "$USE_TUI" -eq 1 ]]; then
    if ! prompt_yes_no_default "Destroy hangar on ${HOST}? This removes beammeup server config." "n"; then
      return 1
    fi
    confirm_text="$(tui_input "confirm destroy" "Type DESTROY to confirm" "")" || return 1
  else
    printf '\nDestroy hangar will remove beammeup server config on %s.\n' "$HOST"
    if ! prompt_yes_no_default "Continue?" "n"; then
      return 1
    fi
    read -r -p "Type DESTROY to confirm: " confirm_text
  fi

  [[ "$confirm_text" == "DESTROY" ]]
}

resolve_install_target() {
  if [[ "$0" == */* ]]; then
    printf '%s' "$0"
    return
  fi

  command -v beammeup 2>/dev/null || printf '%s' "$0"
}

read_remote_version() {
  local file="$1"
  grep -m1 '^BEAMMEUP_VERSION=' "$file" | sed -E "s/^[^\"']*[\"']([^\"']+)[\"'].*/\\1/" || true
}

run_self_update() {
  command -v curl >/dev/null 2>&1 || die "curl is required for self-update."
  command -v chmod >/dev/null 2>&1 || die "chmod is required for self-update."

  local target update_url tmp_file new_version
  target="$(resolve_install_target)"
  update_url="${BASE_URL%/}/beammeup"

  info "beaming to ${update_url}"
  tmp_file="$(mktemp -t beammeup-update.XXXXXX)"
  trap 'rm -f "$tmp_file"' EXIT

  if ! curl -fsSL "$update_url" -o "$tmp_file"; then
    die "update download failed from ${update_url}"
  fi

  if ! head -n 1 "$tmp_file" | grep -q '^#!/usr/bin/env bash'; then
    die "update payload is not a valid beammeup script."
  fi

  new_version="$(read_remote_version "$tmp_file")"
  if [[ -z "$new_version" ]]; then
    new_version="unknown"
  fi

  if [[ ! -w "$target" ]]; then
    die "cannot write to ${target}. Re-run with permissions to replace the binary."
  fi

  mv "$tmp_file" "$target"
  chmod +x "$target"
  trap - EXIT

  if [[ "$new_version" == "unknown" ]]; then
    info "updated (version unknown)"
  elif [[ "$new_version" == "$BEAMMEUP_VERSION" ]]; then
    info "already on beammeup v${BEAMMEUP_VERSION}"
  else
    info "updated to v${new_version}"
  fi
}

print_inventory_summary() {
  local output="$1"
  local socks_exists socks_active socks_port socks_user
  local http_exists http_active http_port http_user http_legacy

  socks_exists="$(extract_value "BM_SOCKS_EXISTS" "$output" || echo 0)"
  socks_active="$(extract_value "BM_SOCKS_ACTIVE" "$output" || echo 0)"
  socks_port="$(extract_value "BM_SOCKS_PORT" "$output" || true)"
  socks_user="$(extract_value "BM_SOCKS_USER" "$output" || true)"

  http_exists="$(extract_value "BM_HTTP_EXISTS" "$output" || echo 0)"
  http_active="$(extract_value "BM_HTTP_ACTIVE" "$output" || echo 0)"
  http_port="$(extract_value "BM_HTTP_PORT" "$output" || true)"
  http_user="$(extract_value "BM_HTTP_USER" "$output" || true)"
  http_legacy="$(extract_value "BM_HTTP_LEGACY" "$output" || echo 0)"

  printf '\n[ship-scan] detected beammeup setups on target:\n'
  if [[ "$socks_exists" == "1" ]]; then
    printf '  SOCKS5: %s, port=%s, user=%s\n' \
      "$( [[ "$socks_active" == "1" ]] && echo active || echo inactive )" \
      "${socks_port:-unknown}" "${socks_user:-unknown}"
  else
    printf '  SOCKS5: not configured\n'
  fi

  if [[ "$http_exists" == "1" ]]; then
    printf '  HTTP:   %s, port=%s, user=%s' \
      "$( [[ "$http_active" == "1" ]] && echo active || echo inactive )" \
      "${http_port:-unknown}" "${http_user:-unknown}"
    if [[ "$http_legacy" == "1" ]]; then
      printf ' (legacy config)'
    fi
    printf '\n'
  else
    printf '  HTTP:   not configured\n'
  fi
}

print_connection_box() {
  local result_action="$1"
  local result_protocol="$2"
  local result_host="$3"
  local result_port="$4"
  local result_user="$5"
  local result_pass="$6"
  local pass_display

  pass_display="${result_pass:-<not retrievable>}"

  printf '+----------------------------------------------------------------+\n'
  box_line "beammeup ${result_action} complete (${result_protocol})"
  printf '|----------------------------------------------------------------|\n'
  box_line "Host: ${result_host}"
  box_line "Port: ${result_port}"
  box_line "Username: ${result_user:-<not available>}"
  box_line "Password: ${pass_display}"
  printf '+----------------------------------------------------------------+\n'
}

HOST=""
SSH_PORT="$DEFAULT_SSH_PORT"
SSH_USER="$DEFAULT_SSH_USER"
SSH_PASSWORD=""
PROTOCOL=""
PROXY_PORT=""
ACTION=""
SHOW_INVENTORY=0
PREFLIGHT_ONLY=0
NO_FIREWALL_CHANGE=0
ROTATE_CREDENTIALS=0
SELF_UPDATE=0
AUTO_UPDATE="${BEAMMEUP_AUTO_UPDATE:-0}"
AUTO_YES=0
BASE_URL="$DEFAULT_BASE_URL"
SHIPS_DIR="${BEAMMEUP_SHIPS_DIR:-$DEFAULT_SHIPS_DIR}"
SHIP_NAME=""
LIST_SHIPS=0

ARG_HOST_SET=0
ARG_SSH_PORT_SET=0
ARG_SSH_USER_SET=0
ARG_PROTOCOL_SET=0
ARG_PROXY_PORT_SET=0
ARG_NO_FIREWALL_SET=0

case "$(to_lower "$AUTO_UPDATE")" in
  1|true|yes|on)
    AUTO_UPDATE=1
    ;;
  *)
    AUTO_UPDATE=0
    ;;
esac

while [[ $# -gt 0 ]]; do
  case "$1" in
    --host)
      [[ $# -ge 2 ]] || die "--host requires a value."
      HOST="$2"
      ARG_HOST_SET=1
      shift 2
      ;;
    --ship)
      [[ $# -ge 2 ]] || die "--ship requires a value."
      SHIP_NAME="$2"
      shift 2
      ;;
    --list-ships)
      LIST_SHIPS=1
      shift
      ;;
    --ssh-port)
      [[ $# -ge 2 ]] || die "--ssh-port requires a value."
      SSH_PORT="$2"
      ARG_SSH_PORT_SET=1
      shift 2
      ;;
    --ssh-user)
      [[ $# -ge 2 ]] || die "--ssh-user requires a value."
      SSH_USER="$2"
      ARG_SSH_USER_SET=1
      shift 2
      ;;
    --ssh-password)
      [[ $# -ge 2 ]] || die "--ssh-password requires a value."
      SSH_PASSWORD="$2"
      shift 2
      ;;
    --protocol)
      [[ $# -ge 2 ]] || die "--protocol requires a value."
      PROTOCOL="$2"
      ARG_PROTOCOL_SET=1
      shift 2
      ;;
    --proxy-port)
      [[ $# -ge 2 ]] || die "--proxy-port requires a value."
      PROXY_PORT="$2"
      ARG_PROXY_PORT_SET=1
      shift 2
      ;;
    --action)
      [[ $# -ge 2 ]] || die "--action requires a value."
      ACTION="$2"
      shift 2
      ;;
    --show-inventory)
      SHOW_INVENTORY=1
      shift
      ;;
    --preflight-only)
      PREFLIGHT_ONLY=1
      shift
      ;;
    --no-firewall-change)
      NO_FIREWALL_CHANGE=1
      ARG_NO_FIREWALL_SET=1
      shift
      ;;
    --rotate-credentials)
      ROTATE_CREDENTIALS=1
      shift
      ;;
    --self-update)
      SELF_UPDATE=1
      shift
      ;;
    --auto-update)
      AUTO_UPDATE=1
      shift
      ;;
    --base-url)
      [[ $# -ge 2 ]] || die "--base-url requires a value."
      BASE_URL="$2"
      shift 2
      ;;
    --version)
      printf 'beammeup v%s\n' "$BEAMMEUP_VERSION"
      exit 0
      ;;
    --yes)
      AUTO_YES=1
      shift
      ;;
    -h|--help)
      print_help
      exit 0
      ;;
    *)
      die "Unknown argument: $1 (run with --help)"
      ;;
  esac
done

if [[ "$SELF_UPDATE" -eq 1 ]]; then
  run_self_update
  exit 0
fi

if [[ "$AUTO_UPDATE" -eq 1 ]]; then
  run_self_update
fi

if [[ "$LIST_SHIPS" -eq 1 ]]; then
  print_ship_list
  exit 0
fi

if [[ -t 0 && -t 1 ]]; then
  USE_TUI=1
fi

if [[ -n "$SHIP_NAME" ]]; then
  SHIP_NAME="$(sanitize_ship_name "$SHIP_NAME")"
  [[ -n "$SHIP_NAME" ]] || die "Invalid --ship name."
  apply_ship_profile "$SHIP_NAME"
  info "ship '$SHIP_NAME' loaded"
fi

if [[ -z "$HOST" ]]; then
  if [[ -t 0 && -t 1 ]]; then
    interactive_ship_wizard
  else
    die "No host provided. Use --host, --ship, or run interactively to create/select a ship."
  fi
fi

is_valid_port "$SSH_PORT" || die "Invalid SSH port: $SSH_PORT"

if [[ -n "$PROTOCOL" ]]; then
  PROTOCOL="$(normalize_protocol "$PROTOCOL" 2>/dev/null || true)"
  [[ -n "$PROTOCOL" ]] || die "Invalid --protocol. Use http or socks5."
fi

if [[ -n "$ACTION" ]]; then
  ACTION="$(normalize_action "$ACTION" 2>/dev/null || true)"
  [[ -n "$ACTION" ]] || die "Invalid --action. Use show, configure, rotate, or destroy."
fi

if [[ -n "$PROXY_PORT" ]]; then
  is_valid_port "$PROXY_PORT" || die "Invalid proxy port: $PROXY_PORT"
fi

if [[ "$PREFLIGHT_ONLY" -eq 1 && -n "$ACTION" ]]; then
  die "Use either --preflight-only or --action, not both."
fi

if [[ "$PREFLIGHT_ONLY" -eq 1 ]]; then
  ACTION="configure"
fi

if [[ -z "$SSH_PASSWORD" ]]; then
  if [[ "$USE_TUI" -eq 1 ]]; then
    SSH_PASSWORD="$(tui_password "ssh credentials" "SSH password for ${SSH_USER}@${HOST}")" || die "Cancelled."
  else
    read -r -s -p "SSH password for ${SSH_USER}@${HOST}: " SSH_PASSWORD
    printf '\n'
  fi
fi

[[ -n "$SSH_PASSWORD" ]] || die "SSH password is required for this MVP."

command -v ssh >/dev/null 2>&1 || die "Missing dependency: ssh"
command -v scp >/dev/null 2>&1 || die "Missing dependency: scp"
command -v sshpass >/dev/null 2>&1 || die "Missing dependency: sshpass (install it, then rerun beammeup)."

TMP_REMOTE_SCRIPT="$(mktemp -t beammeup-remote.XXXXXX)"
REMOTE_SCRIPT_PATH="/tmp/beammeup-remote-$RANDOM.sh"

cleanup() {
  rm -f "$TMP_REMOTE_SCRIPT"
}
trap cleanup EXIT

cat >"$TMP_REMOTE_SCRIPT" <<'REMOTE_SCRIPT'
#!/usr/bin/env bash
set -euo pipefail

log() {
  printf '[remote] %s\n' "$*" >&2
}

die() {
  printf '[remote] ERROR: %s\n' "$*" >&2
  exit 1
}

is_valid_port() {
  local port="$1"
  [[ "$port" =~ ^[0-9]+$ ]] || return 1
  (( port >= 1 && port <= 65535 ))
}

generate_secret() {
  local charset="$1"
  local len="$2"
  local token=""
  while [[ "${#token}" -lt "$len" ]]; do
    token+="$(LC_ALL=C tr -dc "$charset" </dev/urandom | head -c "$len" || true)"
  done
  printf '%s' "${token:0:len}"
}

read_env_value() {
  local file="$1"
  local key="$2"
  if [[ ! -f "$file" ]]; then
    return 1
  fi
  grep -m1 "^${key}=" "$file" | cut -d= -f2- || true
}

service_defined() {
  local unit="$1"
  systemctl cat "$unit" >/dev/null 2>&1
}

service_active() {
  local unit="$1"
  if systemctl is-active --quiet "$unit" 2>/dev/null; then
    printf '1'
  else
    printf '0'
  fi
}

get_public_ip() {
  local ip
  ip="$(curl -4fsS https://api.ipify.org 2>/dev/null || true)"
  if [[ -z "$ip" ]]; then
    ip="$(curl -4fsS https://ifconfig.me 2>/dev/null || true)"
  fi
  if [[ -z "$ip" ]]; then
    ip="$(hostname -I 2>/dev/null | awk '{print $1}')"
  fi
  if [[ -z "$ip" ]]; then
    ip="UNKNOWN"
  fi
  printf '%s' "$ip"
}

find_squid_auth_helper() {
  local candidate
  for candidate in \
    /usr/lib/squid/basic_ncsa_auth \
    /usr/lib64/squid/basic_ncsa_auth \
    /usr/lib/squid3/basic_ncsa_auth
  do
    if [[ -x "$candidate" ]]; then
      printf '%s' "$candidate"
      return 0
    fi
  done
  return 1
}

port_in_use() {
  local port="$1"
  if command -v ss >/dev/null 2>&1; then
    ss -ltn "( sport = :$port )" | tail -n +2 | grep -q .
    return $?
  fi

  if command -v netstat >/dev/null 2>&1; then
    netstat -ltn 2>/dev/null | awk '{print $4}' | grep -qE "[:.]${port}$"
    return $?
  fi

  return 1
}

ensure_port_available() {
  local desired="$1"
  local current="$2"

  if [[ -n "$current" && "$desired" == "$current" ]]; then
    return 0
  fi

  if port_in_use "$desired"; then
    die "Port $desired is already in use."
  fi
}

ensure_requirements() {
  [[ -f /etc/os-release ]] || die "Cannot detect distro (/etc/os-release missing)."
  # shellcheck source=/dev/null
  . /etc/os-release

  case "${ID:-}" in
    ubuntu|debian)
      ;;
    *)
      die "Unsupported distro: ${ID:-unknown}. v1 supports Debian/Ubuntu only."
      ;;
  esac

  (( EUID == 0 )) || die "This installer must run as root."
  command -v apt-get >/dev/null 2>&1 || die "apt-get is required."
  command -v systemctl >/dev/null 2>&1 || die "systemd is required."
}

ensure_packages() {
  local install_needed=0
  local pkg
  local log_file="/tmp/beammeup-install.log"

  for pkg in "$@"; do
    if ! dpkg -s "$pkg" >/dev/null 2>&1; then
      install_needed=1
      break
    fi
  done

  if [[ "$install_needed" -eq 0 ]]; then
    return 0
  fi

  : >"$log_file"
  log "Installing packages: $*"

  if ! DEBIAN_FRONTEND=noninteractive apt-get update >>"$log_file" 2>&1; then
    tail -n 50 "$log_file" >&2 || true
    die "apt-get update failed."
  fi

  if ! DEBIAN_FRONTEND=noninteractive apt-get install -y "$@" >>"$log_file" 2>&1; then
    tail -n 50 "$log_file" >&2 || true
    die "apt-get install failed."
  fi
}

apply_firewall_rule() {
  local port="$1"
  FIREWALL_NOTE="No firewall update applied (port may already be reachable)."

  if [[ "$NO_FIREWALL_CHANGE" -eq 1 ]]; then
    FIREWALL_NOTE="Skipped firewall changes by request."
    return
  fi

  if command -v ufw >/dev/null 2>&1; then
    local ufw_state
    ufw_state="$(ufw status 2>/dev/null | head -n 1 || true)"
    if [[ "$ufw_state" == "Status: active" ]]; then
      if ufw allow "${port}/tcp" >/dev/null 2>&1; then
        FIREWALL_NOTE="Opened TCP ${port} via UFW."
      else
        FIREWALL_NOTE="UFW active, but failed to open TCP ${port}."
      fi
      return
    fi
  fi

  FIREWALL_NOTE="Firewall not modified. Open TCP ${port} manually if blocked."
}

cleanup_firewall_rule() {
  local port="$1"
  [[ -n "$port" ]] || return 0
  is_valid_port "$port" || return 0

  if command -v ufw >/dev/null 2>&1; then
    local ufw_state
    ufw_state="$(ufw status 2>/dev/null | head -n 1 || true)"
    if [[ "$ufw_state" == "Status: active" ]]; then
      ufw delete allow "${port}/tcp" >/dev/null 2>&1 || true
    fi
  fi
}

BEAM_DIR="/etc/beammeup"
SOCKS_ENV="${BEAM_DIR}/microsocks.env"
SOCKS_SERVICE="beammeup-microsocks.service"
SOCKS_SERVICE_FILE="/etc/systemd/system/${SOCKS_SERVICE}"
HTTP_ENV="${BEAM_DIR}/http.env"
HTTP_HTPASSWD="${BEAM_DIR}/http.htpasswd"
SQUID_CONF="/etc/squid/squid.conf"
SQUID_BACKUP="/etc/squid/squid.conf.beammeup.bak"

SOCKS_EXISTS=0
SOCKS_ACTIVE=0
SOCKS_PORT=""
SOCKS_USER=""
SOCKS_PASS=""

HTTP_EXISTS=0
HTTP_ACTIVE=0
HTTP_PORT=""
HTTP_USER=""
HTTP_PASS=""
HTTP_MANAGED=0
HTTP_LEGACY=0

load_socks_state() {
  SOCKS_EXISTS=0
  SOCKS_ACTIVE=0
  SOCKS_PORT=""
  SOCKS_USER=""
  SOCKS_PASS=""

  if [[ -f "$SOCKS_ENV" || -f "$SOCKS_SERVICE_FILE" ]]; then
    SOCKS_EXISTS=1
  fi

  SOCKS_PORT="$(read_env_value "$SOCKS_ENV" PROXY_PORT || true)"
  SOCKS_USER="$(read_env_value "$SOCKS_ENV" PROXY_USER || true)"
  SOCKS_PASS="$(read_env_value "$SOCKS_ENV" PROXY_PASS || true)"

  if service_defined "$SOCKS_SERVICE"; then
    SOCKS_EXISTS=1
    SOCKS_ACTIVE="$(service_active "$SOCKS_SERVICE")"
  fi
}

load_http_state() {
  HTTP_EXISTS=0
  HTTP_ACTIVE=0
  HTTP_PORT=""
  HTTP_USER=""
  HTTP_PASS=""
  HTTP_MANAGED=0
  HTTP_LEGACY=0

  HTTP_PORT="$(read_env_value "$HTTP_ENV" PROXY_PORT || true)"
  HTTP_USER="$(read_env_value "$HTTP_ENV" PROXY_USER || true)"
  HTTP_PASS="$(read_env_value "$HTTP_ENV" PROXY_PASS || true)"

  if [[ -f "$HTTP_ENV" ]]; then
    HTTP_EXISTS=1
    HTTP_MANAGED=1
  fi

  if [[ -f "$SQUID_CONF" ]]; then
    if grep -q "managed by beammeup" "$SQUID_CONF"; then
      HTTP_EXISTS=1
      HTTP_MANAGED=1
    elif grep -q "beammeup-proxy" "$SQUID_CONF"; then
      HTTP_EXISTS=1
      HTTP_LEGACY=1
    fi

    if [[ -z "$HTTP_PORT" ]]; then
      HTTP_PORT="$(awk '/^http_port[[:space:]]+/ {print $2; exit}' "$SQUID_CONF" 2>/dev/null || true)"
    fi
  fi

  if [[ -z "$HTTP_USER" && -f "$HTTP_HTPASSWD" ]]; then
    HTTP_USER="$(awk -F: 'NR==1 {print $1}' "$HTTP_HTPASSWD" 2>/dev/null || true)"
  fi

  if service_defined "squid.service"; then
    if [[ "$HTTP_EXISTS" == "1" ]]; then
      HTTP_ACTIVE="$(service_active "squid.service")"
    fi
  fi
}

print_inventory() {
  load_socks_state
  load_http_state

  printf 'BM_PUBLIC_IP=%s\n' "$(get_public_ip)"

  printf 'BM_SOCKS_EXISTS=%s\n' "$SOCKS_EXISTS"
  printf 'BM_SOCKS_ACTIVE=%s\n' "$SOCKS_ACTIVE"
  printf 'BM_SOCKS_PORT=%s\n' "$SOCKS_PORT"
  printf 'BM_SOCKS_USER=%s\n' "$SOCKS_USER"
  printf 'BM_SOCKS_PASS=%s\n' "$SOCKS_PASS"

  printf 'BM_HTTP_EXISTS=%s\n' "$HTTP_EXISTS"
  printf 'BM_HTTP_ACTIVE=%s\n' "$HTTP_ACTIVE"
  printf 'BM_HTTP_MANAGED=%s\n' "$HTTP_MANAGED"
  printf 'BM_HTTP_LEGACY=%s\n' "$HTTP_LEGACY"
  printf 'BM_HTTP_PORT=%s\n' "$HTTP_PORT"
  printf 'BM_HTTP_USER=%s\n' "$HTTP_USER"
  printf 'BM_HTTP_PASS=%s\n' "$HTTP_PASS"
}

emit_result() {
  local protocol="$1"
  local port="$2"
  local user="$3"
  local pass="$4"
  local action="$5"
  local note="$6"

  printf 'BM_RESULT_PROTOCOL=%s\n' "$protocol"
  printf 'BM_RESULT_HOST=%s\n' "$(get_public_ip)"
  printf 'BM_RESULT_PORT=%s\n' "$port"
  printf 'BM_RESULT_USER=%s\n' "$user"
  printf 'BM_RESULT_PASS=%s\n' "$pass"
  printf 'BM_RESULT_ACTION=%s\n' "$action"
  printf 'BM_RESULT_FIREWALL_NOTE=%s\n' "${FIREWALL_NOTE:-}"
  printf 'BM_RESULT_NOTE=%s\n' "$note"
}

run_preflight() {
  ensure_requirements
  load_socks_state
  load_http_state

  local chosen_port="${PROXY_PORT:-}"
  local current_port=""

  if [[ "$PROTOCOL" == "socks5" ]]; then
    current_port="$SOCKS_PORT"
    if [[ -z "$chosen_port" ]]; then
      chosen_port="${SOCKS_PORT:-1080}"
    fi
  else
    current_port="$HTTP_PORT"
    if [[ -z "$chosen_port" ]]; then
      chosen_port="${HTTP_PORT:-18181}"
    fi
  fi

  is_valid_port "$chosen_port" || die "Invalid proxy port: $chosen_port"
  ensure_port_available "$chosen_port" "$current_port"

  printf 'BM_PREFLIGHT=OK\n'
  printf 'BM_PREFLIGHT_PROTOCOL=%s\n' "$PROTOCOL"
  printf 'BM_PREFLIGHT_PORT=%s\n' "$chosen_port"
}

apply_socks() {
  ensure_requirements
  ensure_packages microsocks curl

  mkdir -p "$BEAM_DIR"

  if ! id -u beammeup >/dev/null 2>&1; then
    useradd --system --no-create-home --shell /usr/sbin/nologin beammeup
  fi

  load_socks_state

  local existed="$SOCKS_EXISTS"
  local desired_port="${PROXY_PORT:-${SOCKS_PORT:-1080}}"
  local final_user="$SOCKS_USER"
  local final_pass="$SOCKS_PASS"
  local note=""

  is_valid_port "$desired_port" || die "Invalid proxy port: $desired_port"
  ensure_port_available "$desired_port" "$SOCKS_PORT"

  if [[ -z "$final_user" || "$ROTATE_CREDENTIALS" -eq 1 ]]; then
    final_user="beam$(generate_secret 'a-z0-9' 5)"
  fi
  if [[ -z "$final_pass" || "$ROTATE_CREDENTIALS" -eq 1 ]]; then
    final_pass="$(generate_secret 'A-Za-z0-9' 20)"
  fi

  local microsocks_bin
  microsocks_bin="$(command -v microsocks || true)"
  [[ -n "$microsocks_bin" ]] || die "microsocks binary not found after install."

  cat >"$SOCKS_ENV" <<EOF_ENV
PROXY_PORT=$desired_port
PROXY_USER=$final_user
PROXY_PASS=$final_pass
EOF_ENV
  chmod 600 "$SOCKS_ENV"

  cat >"$SOCKS_SERVICE_FILE" <<EOF_UNIT
[Unit]
Description=Beammeup SOCKS5 Proxy
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=beammeup
Group=beammeup
EnvironmentFile=$SOCKS_ENV
ExecStart=$microsocks_bin -i 0.0.0.0 -p \${PROXY_PORT} -u \${PROXY_USER} -P \${PROXY_PASS}
Restart=always
RestartSec=2
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=strict
LimitNOFILE=32768

[Install]
WantedBy=multi-user.target
EOF_UNIT
  chmod 644 "$SOCKS_SERVICE_FILE"

  systemctl daemon-reload
  systemctl enable --now "$SOCKS_SERVICE"
  if ! systemctl is-active --quiet "$SOCKS_SERVICE"; then
    journalctl -u "$SOCKS_SERVICE" -n 50 --no-pager >&2 || true
    die "SOCKS5 service failed to start."
  fi

  apply_firewall_rule "$desired_port"

  if [[ "$ROTATE_CREDENTIALS" -eq 1 ]]; then
    note="Credentials rotated."
  fi

  emit_result "SOCKS5" "$desired_port" "$final_user" "$final_pass" \
    "$( [[ "$existed" == "1" ]] && echo updated || echo created )" "$note"
}

apply_http() {
  ensure_requirements
  ensure_packages squid apache2-utils curl

  mkdir -p "$BEAM_DIR"

  if [[ -f "$SQUID_CONF" ]] && ! grep -q "managed by beammeup" "$SQUID_CONF"; then
    if ! grep -q "beammeup-proxy" "$SQUID_CONF"; then
      die "Existing non-beammeup Squid config detected at $SQUID_CONF. Refusing to overwrite."
    fi
  fi

  load_http_state

  local existed="$HTTP_EXISTS"
  local desired_port="${PROXY_PORT:-${HTTP_PORT:-18181}}"
  local final_user="$HTTP_USER"
  local final_pass="$HTTP_PASS"
  local note=""

  is_valid_port "$desired_port" || die "Invalid proxy port: $desired_port"
  ensure_port_available "$desired_port" "$HTTP_PORT"

  if [[ -z "$final_user" || "$ROTATE_CREDENTIALS" -eq 1 ]]; then
    final_user="beamhttp$(generate_secret 'a-z0-9' 4)"
  fi

  if [[ -z "$final_pass" || "$ROTATE_CREDENTIALS" -eq 1 ]]; then
    final_pass="$(generate_secret 'A-Za-z0-9' 20)"
    if [[ "$HTTP_LEGACY" == "1" && "$ROTATE_CREDENTIALS" -eq 0 ]]; then
      note="Legacy HTTP setup detected. Password regenerated because existing password cannot be recovered."
    elif [[ "$ROTATE_CREDENTIALS" -eq 1 ]]; then
      note="Credentials rotated."
    fi
  fi

  local auth_helper
  auth_helper="$(find_squid_auth_helper || true)"
  [[ -n "$auth_helper" ]] || die "Could not locate Squid basic_ncsa_auth helper."

  cat >"$HTTP_ENV" <<EOF_ENV
PROXY_PORT=$desired_port
PROXY_USER=$final_user
PROXY_PASS=$final_pass
EOF_ENV
  chmod 600 "$HTTP_ENV"

  htpasswd -bc "$HTTP_HTPASSWD" "$final_user" "$final_pass" >/dev/null
  chown proxy:proxy "$HTTP_HTPASSWD" 2>/dev/null || true
  chmod 640 "$HTTP_HTPASSWD"

  if [[ -f "$SQUID_CONF" && ! -f "$SQUID_BACKUP" ]]; then
    cp "$SQUID_CONF" "$SQUID_BACKUP"
  fi

  cat >"$SQUID_CONF" <<EOF_SQUID
# managed by beammeup
http_port $desired_port

acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl Safe_ports port 1025-65535
acl CONNECT method CONNECT

http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports

auth_param basic program $auth_helper $HTTP_HTPASSWD
auth_param basic realm beammeup-proxy
auth_param basic credentialsttl 8 hours
acl authenticated proxy_auth REQUIRED

http_access allow authenticated
http_access deny all

forwarded_for delete
request_header_access X-Forwarded-For deny all
request_header_access Via deny all

cache deny all
access_log stdio:/var/log/squid/access.log
cache_log /var/log/squid/cache.log
coredump_dir /var/spool/squid
pid_filename /run/squid.pid
EOF_SQUID

  squid -k parse
  systemctl daemon-reload
  systemctl enable --now squid
  systemctl restart squid

  if ! systemctl is-active --quiet squid; then
    journalctl -u squid -n 50 --no-pager >&2 || true
    die "HTTP proxy (Squid) failed to start."
  fi

  apply_firewall_rule "$desired_port"

  emit_result "HTTP" "$desired_port" "$final_user" "$final_pass" \
    "$( [[ "$existed" == "1" ]] && echo updated || echo created )" "$note"
}

show_setup() {
  ensure_requirements
  load_socks_state
  load_http_state

  if [[ "$PROTOCOL" == "socks5" ]]; then
    [[ "$SOCKS_EXISTS" == "1" ]] || die "SOCKS5 setup not found."
    FIREWALL_NOTE=""
    emit_result "SOCKS5" "${SOCKS_PORT:-}" "${SOCKS_USER:-}" "${SOCKS_PASS:-}" "show" ""
    return
  fi

  [[ "$HTTP_EXISTS" == "1" ]] || die "HTTP setup not found."
  FIREWALL_NOTE=""
  local note=""
  if [[ -z "$HTTP_PASS" ]]; then
    note="Password is not retrievable from legacy setup. Use rotate action to issue a new password."
  fi
  emit_result "HTTP" "${HTTP_PORT:-}" "${HTTP_USER:-}" "${HTTP_PASS:-}" "show" "$note"
}

destroy_hangar() {
  ensure_requirements
  load_socks_state
  load_http_state

  local removed_any=0
  local note_parts=()

  FIREWALL_NOTE=""

  if [[ "$SOCKS_EXISTS" == "1" ]]; then
    if service_defined "$SOCKS_SERVICE"; then
      systemctl disable --now "$SOCKS_SERVICE" >/dev/null 2>&1 || true
    fi
    cleanup_firewall_rule "${SOCKS_PORT:-}"
    rm -f "$SOCKS_ENV" "$SOCKS_SERVICE_FILE"
    removed_any=1
    note_parts+=("SOCKS5 removed")
  fi

  if [[ "$HTTP_EXISTS" == "1" ]]; then
    cleanup_firewall_rule "${HTTP_PORT:-}"

    if service_defined "squid.service"; then
      systemctl disable --now squid >/dev/null 2>&1 || true
    fi

    rm -f "$HTTP_ENV" "$HTTP_HTPASSWD"

    if [[ -f "$SQUID_BACKUP" ]]; then
      cp "$SQUID_BACKUP" "$SQUID_CONF"
      note_parts+=("restored squid backup")
      if service_defined "squid.service"; then
        systemctl enable --now squid >/dev/null 2>&1 || true
      fi
    elif [[ -f "$SQUID_CONF" ]] && (grep -q "managed by beammeup" "$SQUID_CONF" || grep -q "beammeup-proxy" "$SQUID_CONF"); then
      rm -f "$SQUID_CONF"
      note_parts+=("removed beammeup squid config")
    fi

    removed_any=1
    note_parts+=("HTTP removed")
  fi

  systemctl daemon-reload

  if [[ "$removed_any" -eq 1 ]]; then
    emit_result "DESTROY" "$(get_public_ip)" "" "" "destroyed" "${note_parts[*]}"
  else
    emit_result "DESTROY" "$(get_public_ip)" "" "" "destroy-noop" "No beammeup configuration detected."
  fi
}

MODE="inventory"
PROTOCOL=""
PROXY_PORT=""
NO_FIREWALL_CHANGE=0
ROTATE_CREDENTIALS=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --mode)
      MODE="$2"
      shift 2
      ;;
    --protocol)
      PROTOCOL="$2"
      shift 2
      ;;
    --proxy-port)
      PROXY_PORT="$2"
      shift 2
      ;;
    --no-firewall-change)
      NO_FIREWALL_CHANGE=1
      shift
      ;;
    --rotate-credentials)
      ROTATE_CREDENTIALS=1
      shift
      ;;
    *)
      die "Unknown argument: $1"
      ;;
  esac
done

case "$MODE" in
  inventory)
    print_inventory
    ;;
  preflight)
    [[ "$PROTOCOL" == "http" || "$PROTOCOL" == "socks5" ]] || die "--protocol is required for preflight mode."
    run_preflight
    ;;
  show)
    [[ "$PROTOCOL" == "http" || "$PROTOCOL" == "socks5" ]] || die "--protocol is required for show mode."
    show_setup
    ;;
  destroy)
    destroy_hangar
    ;;
  apply)
    [[ "$PROTOCOL" == "http" || "$PROTOCOL" == "socks5" ]] || die "--protocol is required for apply mode."
    if [[ "$PROTOCOL" == "socks5" ]]; then
      apply_socks
    else
      apply_http
    fi
    ;;
  *)
    die "Unknown mode: $MODE"
    ;;
esac
REMOTE_SCRIPT

chmod +x "$TMP_REMOTE_SCRIPT"

SSH_DIR="${HOME:-.}/.beammeup"
SSH_KNOWN_HOSTS="${SSH_DIR}/known_hosts"
mkdir -p "$SSH_DIR"
touch "$SSH_KNOWN_HOSTS"
chmod 600 "$SSH_KNOWN_HOSTS" 2>/dev/null || true

SSH_COMMON_OPTS=(
  -o StrictHostKeyChecking=no
  -o UserKnownHostsFile="$SSH_KNOWN_HOSTS"
  -o ConnectTimeout=15
)

run_scp() {
  SSHPASS="$SSH_PASSWORD" sshpass -e scp "${SSH_COMMON_OPTS[@]}" -P "$SSH_PORT" "$1" "$SSH_USER@$HOST:$2" \
    2> >(tr -d '\r' | grep -v "Permanently added .*known hosts" >&2)
}

run_ssh() {
  SSHPASS="$SSH_PASSWORD" sshpass -e ssh "${SSH_COMMON_OPTS[@]}" -p "$SSH_PORT" "$SSH_USER@$HOST" "$1" \
    2> >(tr -d '\r' | grep -v "Permanently added .*known hosts" >&2)
}

run_remote_mode() {
  local mode="$1"
  local args
  args="--mode $mode"

  if [[ -n "$PROTOCOL" ]]; then
    args="$args --protocol $PROTOCOL"
  fi

  if [[ -n "$PROXY_PORT" ]]; then
    args="$args --proxy-port $PROXY_PORT"
  fi

  if [[ "$NO_FIREWALL_CHANGE" -eq 1 ]]; then
    args="$args --no-firewall-change"
  fi

  if [[ "$ROTATE_CREDENTIALS" -eq 1 ]]; then
    args="$args --rotate-credentials"
  fi

  run_ssh "bash $REMOTE_SCRIPT_PATH $args"
}

phase 1 4 "transporter lock"
printf '[beammeup] target summary:\n'
printf '  Host: %s\n' "$HOST"
printf '  SSH:  %s@%s:%s\n' "$SSH_USER" "$HOST" "$SSH_PORT"
printf '\n'
if [[ "$AUTO_YES" -ne 1 ]]; then
  if ! prompt_yes_no_default "Continue mission to ${HOST}?" "Y"; then
    die "Cancelled."
  fi
fi

phase 2 4 "upload remote command deck"
info "uploading remote command deck..."
run_scp "$TMP_REMOTE_SCRIPT" "$REMOTE_SCRIPT_PATH"

phase 3 4 "ship scan and mission planning"
INVENTORY_OUTPUT=""
if ! INVENTORY_OUTPUT="$(run_remote_mode inventory)"; then
  run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true
  die "Failed to retrieve remote inventory."
fi

SOCKS_EXISTS="$(extract_value "BM_SOCKS_EXISTS" "$INVENTORY_OUTPUT" || echo 0)"
SOCKS_PORT_CURRENT="$(extract_value "BM_SOCKS_PORT" "$INVENTORY_OUTPUT" || true)"
HTTP_EXISTS="$(extract_value "BM_HTTP_EXISTS" "$INVENTORY_OUTPUT" || echo 0)"
HTTP_PORT_CURRENT="$(extract_value "BM_HTTP_PORT" "$INVENTORY_OUTPUT" || true)"

print_inventory_summary "$INVENTORY_OUTPUT"

if [[ "$SHOW_INVENTORY" -eq 1 ]]; then
  run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true
  exit 0
fi

if [[ -z "$PROTOCOL" && "$ACTION" != "destroy" ]]; then
  if [[ "$AUTO_YES" -eq 1 ]]; then
    if [[ "$HTTP_EXISTS" == "1" ]]; then
      PROTOCOL="http"
    elif [[ "$SOCKS_EXISTS" == "1" ]]; then
      PROTOCOL="socks5"
    else
      PROTOCOL="http"
    fi
  else
    PROTOCOL="$(prompt_protocol_choice "http")"
  fi
fi

SELECTED_EXISTS=0
SELECTED_PORT=""
if [[ "$PROTOCOL" == "http" ]]; then
  if [[ "$HTTP_EXISTS" == "1" ]]; then
    SELECTED_EXISTS=1
  fi
  SELECTED_PORT="$HTTP_PORT_CURRENT"
elif [[ "$PROTOCOL" == "socks5" ]]; then
  if [[ "$SOCKS_EXISTS" == "1" ]]; then
    SELECTED_EXISTS=1
  fi
  SELECTED_PORT="$SOCKS_PORT_CURRENT"
fi

if [[ "$PREFLIGHT_ONLY" -eq 1 ]]; then
  ACTION="configure"
fi

if [[ -z "$ACTION" ]]; then
  if [[ "$AUTO_YES" -eq 1 ]]; then
    ACTION="configure"
  else
    if [[ -n "$PROTOCOL" ]]; then
      ACTION="$(prompt_action_choice "$PROTOCOL")"
    else
      ACTION="destroy"
    fi
  fi
fi

if [[ "$ACTION" == "rotate" ]]; then
  ROTATE_CREDENTIALS=1
  ACTION="configure"
fi

if [[ "$ACTION" == "destroy" ]]; then
  if [[ "$PREFLIGHT_ONLY" -eq 1 ]]; then
    run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true
    die "Preflight mode cannot be used with destroy action."
  fi
  if [[ "$AUTO_YES" -eq 0 ]]; then
    if ! confirm_destroy_hangar; then
      run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true
      die "Cancelled."
    fi
  fi
fi

if [[ "$ACTION" == "show" && "$PREFLIGHT_ONLY" -eq 1 ]]; then
  run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true
  die "Preflight mode cannot be used with show action."
fi

if [[ "$ACTION" != "show" && "$ACTION" != "destroy" ]]; then
  if [[ -z "$PROXY_PORT" ]]; then
    if [[ -n "$SELECTED_PORT" ]]; then
      PROXY_PORT="$SELECTED_PORT"
    else
      if [[ "$PROTOCOL" == "http" ]]; then
        PROXY_PORT="$DEFAULT_HTTP_PORT"
      else
        PROXY_PORT="$DEFAULT_SOCKS_PORT"
      fi
    fi

    if [[ "$AUTO_YES" -eq 0 ]]; then
      PROXY_PORT="$(prompt_with_default "Proxy port" "$PROXY_PORT")"
    fi
  fi

  is_valid_port "$PROXY_PORT" || {
    run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true
    die "Invalid proxy port: $PROXY_PORT"
  }
fi

if [[ -n "$SHIP_NAME" ]]; then
  persist_ship_profile "$SHIP_NAME"
fi

REMOTE_MODE=""
if [[ "$ACTION" == "show" ]]; then
  REMOTE_MODE="show"
elif [[ "$ACTION" == "destroy" ]]; then
  REMOTE_MODE="destroy"
elif [[ "$PREFLIGHT_ONLY" -eq 1 ]]; then
  REMOTE_MODE="preflight"
else
  REMOTE_MODE="apply"
fi

phase 4 4 "execute remote action"
RESULT_OUTPUT=""
if ! RESULT_OUTPUT="$(run_remote_mode "$REMOTE_MODE")"; then
  run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true
  die "Remote ${REMOTE_MODE} failed."
fi

run_ssh "rm -f $REMOTE_SCRIPT_PATH" >/dev/null 2>&1 || true

if [[ "$REMOTE_MODE" == "preflight" ]]; then
  PREFLIGHT_RESULT="$(extract_value "BM_PREFLIGHT" "$RESULT_OUTPUT" || true)"
  PREFLIGHT_PROTOCOL="$(extract_value "BM_PREFLIGHT_PROTOCOL" "$RESULT_OUTPUT" || true)"
  PREFLIGHT_PORT="$(extract_value "BM_PREFLIGHT_PORT" "$RESULT_OUTPUT" || true)"
  [[ "$PREFLIGHT_RESULT" == "OK" ]] || die "Preflight failed."

  printf '\nPreflight passed. No changes were made.\n'
  printf '  Protocol: %s\n' "$PREFLIGHT_PROTOCOL"
  printf '  Port: %s\n' "$PREFLIGHT_PORT"
  printf '  Status: ready for launch.\n'
  exit 0
fi

RESULT_PROTOCOL="$(extract_value "BM_RESULT_PROTOCOL" "$RESULT_OUTPUT" || true)"
RESULT_HOST="$(extract_value "BM_RESULT_HOST" "$RESULT_OUTPUT" || true)"
RESULT_PORT="$(extract_value "BM_RESULT_PORT" "$RESULT_OUTPUT" || true)"
RESULT_USER="$(extract_value "BM_RESULT_USER" "$RESULT_OUTPUT" || true)"
RESULT_PASS="$(extract_value "BM_RESULT_PASS" "$RESULT_OUTPUT" || true)"
RESULT_ACTION="$(extract_value "BM_RESULT_ACTION" "$RESULT_OUTPUT" || true)"
RESULT_FIREWALL="$(extract_value "BM_RESULT_FIREWALL_NOTE" "$RESULT_OUTPUT" || true)"
RESULT_NOTE="$(extract_value "BM_RESULT_NOTE" "$RESULT_OUTPUT" || true)"

if [[ -z "$RESULT_HOST" || "$RESULT_HOST" == "UNKNOWN" ]]; then
  RESULT_HOST="$HOST"
fi

if [[ "$RESULT_PROTOCOL" == "DESTROY" ]]; then
  printf '\n[beammeup] destroy hangar complete.\n'
  printf '  Target: %s\n' "$RESULT_HOST"
  if [[ -n "$RESULT_NOTE" ]]; then
    printf '  Result: %s\n' "$RESULT_NOTE"
  fi
  printf '\n[beammeup] jump successful.\n'
  exit 0
fi

printf '\n'
print_connection_box \
  "$RESULT_ACTION" \
  "$RESULT_PROTOCOL" \
  "$RESULT_HOST" \
  "$RESULT_PORT" \
  "$RESULT_USER" \
  "$RESULT_PASS"

if [[ -n "$RESULT_FIREWALL" ]]; then
  printf '\nFirewall note: %s\n' "$RESULT_FIREWALL"
fi

if [[ -n "$RESULT_NOTE" ]]; then
  printf 'Note: %s\n' "$RESULT_NOTE"
fi

printf '\n[beammeup] jump successful.\n'

printf '\nChrome extension setup:\n'
if [[ "$RESULT_PROTOCOL" == "HTTP" ]]; then
  printf '  Type: HTTP proxy\n'
  printf '  Server: %s\n' "$RESULT_HOST"
  printf '  Port: %s\n' "$RESULT_PORT"
  printf '  Enter username/password when prompted\n'
  printf "\nQuick test:\n"
  if [[ -n "$RESULT_PASS" ]]; then
    printf "  curl -x 'http://%s:%s@%s:%s' https://api.ipify.org\n" \
      "$RESULT_USER" "$RESULT_PASS" "$RESULT_HOST" "$RESULT_PORT"
  fi
else
  printf '  Type: SOCKS5\n'
  printf '  Server: %s\n' "$RESULT_HOST"
  printf '  Port: %s\n' "$RESULT_PORT"
  printf '  Username/Password: use values above\n'
  printf "\nQuick test:\n"
  if [[ -n "$RESULT_PASS" ]]; then
    printf "  curl -x 'socks5h://%s:%s@%s:%s' https://api.ipify.org\n" \
      "$RESULT_USER" "$RESULT_PASS" "$RESULT_HOST" "$RESULT_PORT"
  fi
fi
